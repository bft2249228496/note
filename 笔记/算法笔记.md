## 常说的算法题，就是编程题，题目类型是遍历的
## 数组特点：数据连续，随机访问跟数据在内存里存储的方式比较像
## 链表特点：非连续的存储
## 其他数据结构都可以通过数组和链表得到
## 哈希碰撞
## 二叉树：多叉树可以简化成二叉树，二叉树比较利于存储
## 字典
## 算法：1.排序 2.搜索 3.递归 4.回溯 5.贪心 6.动态
## ------------------------------------------------
## 数据结构：(栈，队列，链表)，(集合，字典)，(树，堆，图)
## 进阶算法：冒泡算法，选择算法，插入算法，归并算法，快速算法，顺序算法，二分搜索
## 算法设计思想：分而治之，动态规划，贪心，回溯
## 重点：数据结构与算法的特点，应用场景，JS实现，时间/空间复杂度
## 刷题网站：LeetCode，刷题顺序：按照类型刷题，集中训练
## 程序=数据结构+算法
## 链表：遍历链表，删除链表节点
## 树，图：深度、广度优先遍历
## 数组：冒泡/选择/插入/归并/快速排序、顺序/二分搜索
## 时间复杂度：O(n)其实就是代码执行的次数(相乘满足数学乘法规则，相加则取增长趋势更大的那个)
## 空间复杂度：O(n)其实就是声明变量的个数(相乘满足数学乘法规则，相加则取增长趋势更大的那个)
## 在计算机科学中，除非有特殊的说明，否则所有的对数都是以2为底的。即logN的底数为2
## 最后调用的函数最先被执行完
## 用一快一慢两个指针遍历链表，如果链表有环，一定能相遇
## 如果A沿着原型链能找到B.prototype,那么A instanceof B 为true
## object和Map存储的都是键值对组合。但是：object的键的类型是 字符串；map的键的类型是 可以是任意类型；
## 求两个Set交集的方法：new Set([...set1].filter(item => set2.has(item)))
## js中可以用object和array构建树，构建图
## 栈：先进后出，后进先出。场景：10进制转2进制，有效的括号，函数调用堆栈
## 队列：先进先出，后进后出。场景：食堂排队打饭，JS异步中的任务队列，计算最近请求次数
## 链表：多个元素组成的列表，元素存储不连续，用next指针连在一起。链表无法直接获取被删除节点的上个节点
## 数组：增删非首尾元素时往往需要移动元素
## 集合：一种无序且唯一的数据结构，ES6里面的Set就是集合。
## 字典：与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储，ES6中的Map就是字典。
## 树：一种分层数据的抽象模型
## 图：图是网络结构的抽象模型，是一组由边连接的节点
## 二叉树：树中每个节点最多只能有两个子节点
## 堆：一种特殊的完全二叉树。完全二叉树：每层节点都完全填满，最后一层节点即使不是满的，也只是欠缺右边的若干节点,js中经常用数组表示堆.(任意节点的左侧子节点的位置为2 * index + 1;任意节点的右侧子节点的位置为2 * index + 2;任意节点的父节点位置是（index - 1) / 2
## 堆的特点：所有节点都大于等于(最大堆)或小于等于(最小堆)它的子节点
## 堆的应用：堆能高效、快速地找出最大值和最小值，时间复杂度O(1);找出第K个最大(小)元素
## 第K个最大元素：构建一个最小堆，并将元素依次插入堆中；当堆的容量超过k，就删除堆顶；插入结束后，堆顶就是第k个最大元素(若求第k最小元素，则可以类似的创建最大堆)
## 树的深度优先遍历：尽可能深的搜索树的分支；算法步骤：访问根节点，对根节点的children挨个进行深度优先遍历
## 树的广度优先遍历：先访问离根节点最近的节点；算法步骤：新建一个队列，把根节点入队；把队头出队并访问；把队头的children挨个入队；重复第二，三步，直到队列为空
## 先序遍历:算法步骤：访问根节点；对根节点的左子树进行先序遍历；对根节点的右子树进行先序遍历(根左右)
## 中序遍历：算法步骤：对根节点的左子树进行中序遍历；访问根节点；对根节点的右子树进行中序遍历(左根右)
## 后序遍历：算法步骤：对根节点的左子树进行后序遍历；对根节点的右子树进行后序遍历；访问根节点(左右根)
## 二叉树的最大深度为根节点到最远叶子节点的最长路径上的节点数，二叉树的最小深度为从根节点到最近叶子节点的最短路径上的节点数量(叶子节点是指没有子节点的节点)
## 图的表示法：邻接矩阵，邻接表，关联矩阵
## 邻接矩阵：两点相连交叉位为1，其他位为0
## 邻接表：用对象表示，两点相连，其中一个点位对象的键，另一个点为对象的值(值用数组/链表来表示)
## 图的常用操作：深度优先遍历和广度优先遍历。
## 图的深度优先遍历：尽可能深的搜索图的分支；算法步骤：访问根节点；对根节点的没访问过的相邻节点挨个进行深度优先遍历
## 图的广度优先遍历：先访问离根节点最近的节点；算法步骤：新建一个队列，把根节点入队；把队头出队并访问；把队头的没访问过的相邻节点入队；重复第二，三步，直到队列为空
## 排序算法：把某个乱序的数组变成升序或者降序的数组。JS中的排序一般用数组的sort方法。
## 搜索算法：找出数组中某个元素的下标，JS中的排序一般用数组的indexOf方法
## 排序算法的具体类型：冒泡排序，选择排序，插入排序，归并排序，快速排序
## 搜索算法的具体类型：顺序搜索，二分搜索
## 冒泡排序思路：比较所有相邻元素，如果第一个比第二个大，则交换它们；一轮下来，可以保证最后一个数是最大的；执行n-1轮，就可以完成排序
## 选择排序思路：找到数组中的最小值，选中它并将其放置在第一位；接着找到第二小的值，选中它并将其放置在第二位；以此类推，执行n-1轮

