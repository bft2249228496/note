## const 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动
## es6声明变量的6种方法: var, function, let, const, import, class
## 浏览器的顶层对象是window,Node环境中顶层对象是global
## padStart(),padEnd()
## trim可消除模板字符串的换行
## Number.isInteger()判断一个值是否为整数
## Math.trunc() 去掉一个数的小数部分，返回整数部分,对于非数值会内部先调用Number方法(注意与parseInt的区别，parseInt在数字很大或者很小的时候会有问题，例如用科学计数法表示的数字)
## Math.sign()用来判断一个数是正是负还是零,正数返回1，负数返回-1，为0返回0，-0返回-0，其他值返回NaN
## Math.cbrt()用于计算一个数的立方根
## 箭头函数：如果箭头函数不需要参数或者需要多个参数，就是用圆括号代表参数部分；如果箭头函数的代码块部分多于一条语句，就要使用大括号将其括起来，并使用return 语句返回；如果箭头函数直接返回一个对象，必须在对象外面加上括号
## 函数绑定运算符是并排的双冒号(::),冒号左边是对象，右边是函数。由于双冒号运算符返回的是原对象，所以可采用链式写法
## 递归：函数调用自身称为递归。如果尾调用自身就称为尾递归。
## 扩展运算符(...),如同rest参数的逆运算，将一个数组转为用逗号分隔的参数序列
## Array.from方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象(包括Set和Map结构)
## Array.of方法用于将一组值转换为数组
## 数组实例方法查找第一个符合条件的数组成员：find：找到返回该成员，找不到返回undefined；findIndex：找到返回该成员索引，找不到返回-1
## fill填充数组
## 遍历数组：entries,keys,values
## includes：返回一个布尔值，表示某个数组是否包含给定的值
## 数组的空位值数组的某一个位置没有任何值。(空位不是undefined，一个位置的值等于undefined依然是有值的，有些数组方法会将空位转为undefined)
## ES6允许在对象中只写属性名，不写属性值。此时，属性值等于属性名所代表的变量。方法也可以简写成method () {}
## ES6简洁写法中属性名总是字符串
## 如果对象的方法使用了取值函数getter和存值函数setter，name属性的返回值为方法名前加上get和set。bind方法创造的函数，name属性返回bound加上原函数名；Function构造函数创造的函数，name属性返回anonymous；如果对象的方法是个Symbol值，name属性返回Symbol的描述
## 同值相等：Object.is，NaN等于NaN，+0不等于-0,0不等于-0，0等于+0
## Object.assign将源对象的所有可枚举属性复制到目标对象(浅复制)
## Symbol函数的参数只表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的
## Symbol值作为对象属性名时不能使用点运算符，在对象的内部，使用Symbol值定义属性时，Symbol必须放在方括号中
## Symbol作为属性名时，无法被普通方法遍历，可使用Object.getOwnPropertySymbols返回当前对象的所有用作属性名的Symbol值的一个数组；另一个方法是Reflect.ownKeys,该方法返回所有类型的键名，包括常规键名和Symbol键名
## Map结构：类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值(包括对象)都可以当作键
## WeakMap结构：与Map类似，也用于生成键值对的集合。但是有两个区别：1.weakMap只接受对象作为键名(null除外)，不接受其他类型的值作为键名；2.WeakMap的键名所指向的对象不计入垃圾回收机制
## Set结构：类似于数组，但是成员的值都是唯一的，没有重复
## WeakSet结构：与Set类似，也是不重复的值的集合。但是有两个区别：1.WeakSet的成员只能是对象，而不能是其他类型的值；2.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用
## proxy：代理/拦截器，构造函数用法new Proxy(target, handler)，target是所要代理/拦截的目标对象，handler用来定义拦截行为。一般用来扩展或增强对象的一些功能
## proxy的实例方法：set设置的时候干的事情，get获取的时候干的事情，deleteProperty删除，has有没有这个歌东西，apply调用函数的时候做的事情
## Reflect:映射，映射一些明显属于对象语言内部的方法，目前是共存于object和reflect上，未来只在reflect上，让object操作都变成函数行为(reflect和proxy对象的方法一一对应)
## Promise:异步编程,特点：对象的状态不受外界影响；一旦状态改变就不会再变，任何时候都可以得到这个结果。缺点：无法中途取消promise，一旦建立就会立即执行；如果不设置回调函数，promise内部抛出的错误不会反应到外部；当处于pending状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)
## 调用生成器函数会生产一个遍历器对象，一个对象的Symbol.iterator属性也是一个遍历器对象生成函数，执行后返回它自己
## Generator 函数体外抛出的错误可以在函数体内捕获；Generator 函数体内抛出的错误也可以被函数体外的catch捕获
## 在Generator 函数里面调用Generator 函数是没有效果的，yield*语句可用来在一个Generator函数里执行另一个函数
## yield*后面的Generator函数(没有return语句时)等同于在Generator函数内部部署一个for...of循环.当yield*后面跟的Generator函数有return语句时需要通过var value = yield* iterator的形式获取return语句的值
## 协程：一个线程(或函数)执行到一半，可以暂停执行，将执行权交给另一个线程(或函数),等到稍后收回执行权时再恢复执行。这种可以并行执行,交换执行权的线程(或函数)，就称为协程。
## 回调函数：把任务的第二段单独写在一个函数里面，等到重新执行这个任务时便直接调用这个函数。回调函数的英文名字是callback，直译过来就是'重新调用'
## 回调函数地狱：多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数就都要跟着修改
## promise对象：不是新的语法功能，只是一种新的写法，为了解决回调函数地狱的问题，允许将回调函数的嵌套改写成链式调用
## Thunk函数：编译器的'传名调用'的实现往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就是Thunk函数.js语言是传值调用，所以js中的Thunk函数替换的不是表达式，而是多参数函数，将其替换成一个只接受参数的单参数函数
## async函数是Generator函数的语法糖，将*替换成async，将yield替换成await
## async函数自带执行器，它的执行和普通函数一模一样
## async...then函数中，async函数内部的正常返回值会作为参数被then的第一个恶回调函数接收，抛出的错误会作为参数被第二个回调函数接收
## async的多个await命令后面的异步操作如果不存在继发关系，最好让它们同时触发:方法一通过let [foo, bar] = await Promise.all([getFoo(), getBar()])形式；方法二：将函数调用写在await前面，通过变量赋值将变量放到await后面
## await命令只能用在async函数中
## async函数的实现原理就是将Generator函数和自动执行器包装在一个函数里
## for...of用于遍历同步的Iterator接口，for await...of可用于遍历异步的Iterator，也可以用于同步遍历
## 函数形式有4种：普通函数，async函数，Generator函数，异步Generator函数
## yield*也可以与一个异步遍历器一同使用
## ES6的类完全可以看成构造函数的另一种写法，类的数据类型就是函数，类本身就指向构造函数，使用的时候也是直接对类使用new命令，跟构造函数的用法完全一致
## 定义类的方法时，前面不需要加上function这个保留字，直接把函数定义放进去就可以了，方法之间不需要逗号分隔，加了会报错
## 构造函数的prototype属性在ES6的类上继续存在，事实上，类的所有方法都定义在类的prototype属性上(constructor除外)，在类的实例上调用方法，其实就是调用原型上的方法
## 类的内部定义的所有方法都是不可枚举的(这点与ES5不同)
## 类和模块的内部默认使用严格模式
## 与函数一样，Class也可以使用表达式的形式定义，采用Class表达式，也可以写出立即执行的类,如let a = new Class {}
## 类不存在变量提升
## 类相当于实例的原型，所有在类中定义的方法都会被实例继承。如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类调用，称为'静态方法'
## ES6明确规定Class内部只有静态方法，没有静态属性
## ES7类的实例属性可以用等式写入类的定义之中,类的静态属性只要在实例属性写法前面加上static关键字就可以了
## Class内部调用new.target,返回当前Class，子类继承父类时,new.target会返回子类，在函数外部使用new.target会报错
## 子类继承父类必须在constructor方法中调用super方法，否则新建实例时会报错
## Object.getPrototypeOf方法可以用来从子类上获取父类
## super的两个功能：1.作为函数调用，代表父类的构造函数(super()相当于A.prototype.constructor.call(this))；2.作为对象时：在普通方法中指向父类的原型对象(super.p()相当于A.prototype.p())；在静态方法中指向父类
## 由于super会绑定子类的this，如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性，即super.p = this.p
## 对象(类)的静态方法(属性)使用时都是对象(类).静态方法(属性)，实例方法(属性)使用时：1.实例.方法(属性)；2.对象(类).prototype.方法(属性)
## 子类的__proto__属性表示构造函数的继承，总是指向父类，子类的prototype属性的__proto__属性表示方法的继承，总是指向父类的prototype属性
## ES6允许继承原生构造函数定义子类，使得父类的所有行为都可以继承(这是ES5无法做到的)
## 修饰器：Decorator，是一个函数，用来修改类的行为。修饰器对类的行为的改变是在代码编译时发生的，而不是在运行时，其本质就是编译时执行的函数
## 模块：module，其功能主要又两个命令构成：export输出和import输入
## export命令除了输出变量，还可以输出函数或类。通常情况下，export输出的变量就是本来的名字，但是也可以使用as关键字重命名。export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系
## import命令接受一个对象，里面知道要从其他模块导入的变量名。大括号中的变量名必须与被导入模块对外接口的名称相同。import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件可以js引擎盖模块的位置
## import * 总体加载一个模块
## export default 命令用于指定模块的默认输出。因为一个模块只能有一个默认输出，所以export default 命令只能使用一次，此时import命令后面可以不用大括号
## import()方法适用场合：按需加载，条件加载，动态的模块路径。(import()加载模块成功后，这个模块会作为then方法的参数，可通过对象解构赋值的语法获取输出接口)
## ES6模块与CommonJS模块的差异：CommonJS模块输出的是一个值的复制，ES6模块输出的是值的引用;CommonJS模块是运行时加载，ES6模块是编译时输出接口
## 编程风格：1.let代替var；2.在全局环境中，有可能尽量优先const；3.静态字符串使用单引号或反引号，动态字符串使用反引号；4.使用数组对变量赋值时，优先使用解构赋值；函数的参数如果是对象的成员，优先使用解构赋值；如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值;5.单行定义的对象，最后一个成员不易逗号结尾；多行定义的对象，最后一个次元已逗号结尾；6.对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法；7.如果对象的属性名时动态的，可以在创建对象的时候使用属性表达式定义;8.使用扩展运算符(...)复制数组，使用Array.from方法将类似数组的对象转为数组
## const相当于let的优点：1.const可以提醒阅读程序的人，这个变量不应该改变；2.const比较符合函数式编程的思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；3.JavaScript编译器会对const进行优化，有利于提供程序的运行效率